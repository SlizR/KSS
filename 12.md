# What do you need to do to write your own kernel?

## Step 1. Define the kernel philosophy (required)

Before creating folders, you must answer the **5 questions**.

## 1. Who is the kernel for?

* educational
* research
* minimalist
* extensible

This affects:

* complexity
* flexibility
* number of abstraction levels

## 2. What the kernel must do

Minimum set:

* run
* manage memory
* manage execution
* respond to events

Everything else is optional.

## 3. What the kernel will NOT do

It is very important to explicitly state:

* no binary compatibility
* no legacy
* no automagic

---

# Step 4. Define the main subsystems

Don't implement – ​​**name and describe**.

Required subsystems:

### 1. Boot / Entry

Responsible for:

* taking control
* initialization
* transitioning to the running state

### 2. CPU Management

Responsible for:

* processor modes
* execution context
* switching

### 3. Memory Management

Responsible for:

* memory accounting
* isolation
* allocation

### 4. Interrupt & Event System

Responsible for:

* hardware events
* timers
* system responses

### 5. Execution Model

Responsible for:

* tasks
* processes
* scheduling

### 6. Core Services

Common mechanisms:

* synchronization
* queues
* basic data structures

---

# Step 5. Creating your kernel architecture

Use non-random folder names What's important for the system and for understanding you, not drt/tree, etc.

We will always use the following structure:

```text
kernel/
├─ entry/
│ └─ start
├─ platform/
│ └─ cpu
│ └─ memory
│ └─ interrupts
├─ core/
│ └─ scheduler
│ └─ execution
│ └─ events
├─ services/
│ └─ sync
│ └─ time
│ └─ objects
├─ internal/
│ └─ types
│ └─ config
│ └─ contracts
```

---

# Step 6. Rigidly define boundaries

The most common mistake is **shifting responsibility**.

You must decide in advance:

* who can call whom
* who CANNOT
* where is the single entry point

Example:

* entry → platform
* platform → core
* core → services
* services DO NOT interfere with platform
