## General Kernel Structure

The kernel is not a single file or a single program.
It is a **set of interconnected subsystems**, each responsible for its own area.

In simplified form, the structure looks like this:

```text
Hardware
↓
Low-level core
↓
Kernel subsystems
↓
System interface
```

---

## 1. Low-level kernel

This is the very first kernel code to execute.

It is responsible for:

* initial processor initialization
* setting operating modes
* basic memory initialization
* accepting control from the bootloader

Features:

* dependent on processor architecture
* tightly coupled with hardware
* executed before other parts of the kernel start

This is the foundation without which the kernel cannot function.

---

## 2. Architecture-Dependent Part

Each processor type has its own characteristics.

This part of the kernel:

* Knows how to work with a specific architecture
* Sets up registers and interrupts
* Manages processor modes

When porting the kernel to a different architecture, this part is the first to change.

---

## 3. Task Scheduler

The scheduler decides:

* Which program is currently running
* How long it can run
* When it should be suspended

It creates the appearance of multiple programs running in parallel, even on a single processor.

This is the key subsystem for multitasking.

---

## 4. Memory Management

The memory subsystem is responsible for:

* RAM allocation
* memory deallocation
* address space protection
* virtual memory

It prevents situations where:

* one program corrupts another's data
* an error causes the entire system to crash

---

## 5. Interrupt and Event Subsystem

Devices operate asynchronously and generate events.

The kernel:

* receives interrupts
* determines their source
* calls appropriate handlers
* returns to the interrupted task

This allows the system to respond to input, timers, and hardware events.

---

## 6. Device Subsystem

The kernel provides a unified interface for working with devices.

It:

* abstracts the differences between hardware
* manages input and output
* provides standardized access to devices

Programs don't know how a device is actually built—this is hidden by the kernel.

---

## 7. File Subsystem

Even if data is physically stored differently, the kernel:

* represents it as files and directories
* manages access
* synchronizes read and write operations

The file system is a logical layer above the actual storage medium.

---

## 8. System Interface

This is the boundary between the kernel and programs.

Through it, programs can:

* request resources
* work with files
* interact with devices
* run other programs

This interface isolates the kernel from user code.

---

## Kernel Language Framework

The kernel is written in languages ​​that allow:

* precise memory management
* operation without a standard runtime environment
* performance control

Commonly used:

### Low-level languages

Used for:

* system startup
* processor interaction
* interrupt handling

### System languages

Used for:

* kernel logic
* resource management
* subsystem implementation

The choice of languages ​​is a balance between:

* hardware control
* reliability
* development complexity

---

## Monolithic and modular

By kernel structure, there are:

* **monolithic** — all subsystems are in a single address space
* **modular** — parts of the kernel can be connected and disconnected
* **microkernel** — a minimal kernel plus services outside of it

This architectural decision affects:

* performance
* stability
* complexity Development

---

## Summary

The kernel is:

* a strictly structured system
* a set of subsystems with clear responsibilities
* a software layer between the hardware and everything else

It starts with minimal code and gradually accumulates functionality.
